{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Personal documentation on some useful commands and what they do, in prep for CKA exam.</p> <p>This documentation is in the very early stages, structure and updates will change a lot!</p> <p>Commands:</p> <ul> <li>WIP Commands</li> <li>Imperative Commands</li> <li>Network Commands</li> <li>Crictl Commands</li> </ul> <p>Information:</p> <ul> <li>Etcd FAQ</li> <li>Diagnose Crashed Apiserver</li> <li>YAML FAQ</li> <li>Vi 101</li> </ul>"},{"location":"commands/WIP/","title":"WIP Commands","text":"<p>This documentation is in the very early stages. So the structure of everything is not figured out yet. This page contains a bunch of commands that are useful, but don't belong on a page yet.</p>"},{"location":"commands/WIP/#display-information-about-a-process","title":"Display information about a process","text":"<pre><code>ps -aux | grep &lt;process&gt;\n</code></pre>"},{"location":"commands/WIP/#force-delete-a-pod-because-exam-environment-is-slow","title":"Force delete a pod because exam environment is slow","text":"<pre><code>kubectl delete pods &lt;pod&gt; --grace-period=0 --force\n</code></pre>"},{"location":"commands/crictl/","title":"Crictl useful commands","text":"<p>Further reading: https://kubernetes.io/docs/tasks/debug/debug-cluster/crictl/</p>"},{"location":"commands/crictl/#list-all-containers","title":"List all containers","text":"<pre><code>crictl ps -a\n</code></pre>"},{"location":"commands/crictl/#execute-a-command-in-a-container","title":"Execute a command in a container","text":"<pre><code>crictl exec -i -t &lt;id&gt; ls\n</code></pre>"},{"location":"commands/crictl/#container-logs","title":"Container logs","text":"<pre><code>crictl logs &lt;id&gt;\n</code></pre>"},{"location":"commands/imperative/","title":"Imperative useful commands","text":"<p>This page shows most common and basic use cases, refer to the kubectl reference documentation for more in depth imperative commands.</p> <p>https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands</p>"},{"location":"commands/imperative/#creating-a-deployment","title":"Creating a deployment","text":"<pre><code>kubectl create deployment nginx --image nginx --replicas=3\n</code></pre>"},{"location":"commands/imperative/#scale-a-deployment","title":"Scale a deployment","text":"<pre><code>kubectl scale deployment nginx --replicas=4\n</code></pre>"},{"location":"commands/imperative/#creating-a-pod","title":"Creating a pod","text":"<pre><code>kubectl run nginx-pod --image nginx\n</code></pre>"},{"location":"commands/imperative/#exposing-a-pod","title":"Exposing a pod","text":"<pre><code>kubectl expose pod nginx-pod --port 8080\n</code></pre>"},{"location":"commands/imperative/#creating-an-ingress","title":"Creating an ingress","text":"<pre><code>kubectl create ingress &lt;ingress-name&gt; --rule=\"host/path=service:port\"\n</code></pre>"},{"location":"commands/imperative/#creating-these-as-yaml-files-to-edit-further","title":"Creating these as YAML files to edit further","text":"<p>Simply add <code>--dry-run=client -o yaml &gt; filename.yaml</code> to any imperative command</p> <pre><code>kubectl run nginx-pod --image nginx --dry-run=client -o yaml &gt; nginx-pod.yaml\n</code></pre>"},{"location":"commands/network/","title":"Networking useful commands","text":""},{"location":"commands/network/#show-ip-interfaces","title":"Show IP interfaces","text":"<pre><code>ip address\n</code></pre> <p>or</p> <pre><code>ip link\n</code></pre>"},{"location":"commands/network/#show-ip-interface-that-has-the-type-bridge","title":"Show IP interface that has the type bridge","text":"<pre><code>ip address show type bridge\n</code></pre>"},{"location":"commands/network/#list-routes","title":"List routes","text":"<pre><code>ip routes\n</code></pre>"},{"location":"commands/network/#show-ports-that-a-resource-is-listening-to","title":"Show ports that a resource is listening to","text":"<pre><code>netstat -nplt | grep -i &lt;resource&gt;\n</code></pre>"},{"location":"commands/network/#show-ports-that-a-resource-has-established-connection-to","title":"Show ports that a resource has established connection to","text":"<pre><code>netstat -npat | grep -i &lt;resource&gt;\n</code></pre>"},{"location":"information/diagnose-crashed-apiserver/","title":"How to Diagnose a Crashed API Server","text":"<p>Source: https://github.com/kodekloudhub/community-faq/blob/main/docs/diagnose-crashed-apiserver.md</p> <p>The API server pod won't come back up - HELP</p> <p>Perhaps you've made a manifest edit, or perhaps some question has put you into a context where the API server is already broken. You're using <code>docker ps</code> or <code>crictl ps</code> and see the API server flash up briefly then go away. The container doesn't last long enough for you to grab an ID to pull logs from. Or maybe it never appears in the <code>ps</code> output.</p> <p>Note that these techniques can be used for the other static pods like <code>etcd</code>, <code>kube-controller-manager</code> and <code>kube-scheduler</code> by looking for the corresponding name instead of <code>apiserver</code> in the commands below.</p> <p>Steps to take</p> <ol> <li> <p>Restart <code>kubelet</code> so you don't have to wait too long in the following steps <code>systemctl restart kubelet</code></p> </li> <li> <p>Determine if the kubelet can even start the API server     If there is a syntax error in the YAML manifest, then kubelet will not be able to parse it and will eventually complain. Do the following and watch the output for up to 60 seconds. Note that if you have errors in your pod manifest, kubelet will report them exactly the same way using the same kind of error messages that kubectl does!</p> <p><code>journalctl -fu kubelet | grep apiserver</code></p> <p>There are normally three classes of error we will see here</p> <ol> <li> <p>Could not process manifest file</p> <p>This is indicative of an error in the YAML of <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code>. You should go directly to edit that file and correct the issue.Note that YAML parsers only report the first error they find. If you have more than one error - i.e. the apiserver doesn't come up after fixing whatever you've found, then repeat this diagnostic process from the top.</p> </li> <li> <p>Structure or argument error</p> <p>The YAML has been parsed successfully, however you get some cryptic message about something or other. This means that although there's no syntax issues, what you've put in the manifest does not correctly represent the spec for the API server pod, or an argument for something like a volume mount is an invalid path. You need to find and fix this in the manifest file. See also YAML - Dealing with errors.</p> </li> <li> <p>CrashLoopBackOff</p> <p>This means that the YAML was successfully parsed, the pod started and then exited with an error. To fix this, continue reading.</p> </li> </ol> </li> <li> <p>Kubelet does launch API server, but it crashes immediately.     This means there is likely an issue with one or more arguments to the <code>kube-apiserver</code> command. There is a location where the last output of the pod is stored, which can help you to get information about why the pod is not starting.</p> <p><code>cd /var/log/pods ls -ld *apiserver*</code></p> <p>This should return something like</p> <p><code>drwxr-xr-x 3 root root 4096 Oct 26 04:29 kube-system_kube-apiserver-controlplane_02d13ddeddf8e935ec2407132767aeaa</code></p> <p>If there's more than one match, choose the one with the most recent timestamp.</p> <p>NOTE: This directory can change name frequently. If you have to repeat the diagnostic process, don't assume it is the same as last time you did this in the same session. Repeat this step from the top.</p> <p>Next, <code>cd</code> into the given directory</p> <p><code>cd kube-system_kube-apiserver-controlplane_02d13ddeddf8e935ec2407132767aeaa ls -l</code></p> <p>You should see</p> <p><code>drwxr-xr-x 2 root root 4096 Oct 26 04:29 kube-apiserver</code></p> <p><code>cd kube-api-server ls -l</code></p> <p>There will be one or more <code>.log</code> files. Examine the content of the most recent log, e.g.</p> <p><code>cat 1.log</code></p> <p>The issue should be revealed here.</p> </li> </ol> <p>You can use one of kodeklouds Kubernetes playgrounds, or any Kubernetes lab (just ignore the questions).</p> <p>Use this repo to get some scenarios to practice with. This is the repo used in the above video.</p>"},{"location":"information/etcd/","title":"ETCD FAQ","text":"<p>Source: https://github.com/kodekloudhub/community-faq/blob/main/docs/etcd-faq.md</p> <p><code>etcd</code> is a distributed key-value store, kind of similar to a NoSQL database. It is the database backend chosen by the Kubernetes project for the storage of cluster state. It is a separate open source project that is not maintained by the Kubernetes developers, but no doubt they have some input on its development.</p> <ul> <li>What is ETCDCTL_API=3 all about?</li> <li>When do I use --endpoints?</li> <li>What are all the certificates used for?</li> <li>Should I stop API server and/or etcd during backup or restore?</li> <li>How do I make a backup?</li> <li>How do I restore a backup?<ul> <li>kubeadm clusters with etcd running as a pod</li> <li>Troubleshooting after the restore</li> </ul> </li> <li>Clusters with external etcd<ul> <li>Single etcd process</li> <li>Multiple etcd processes</li> </ul> </li> <li>Advanced Usage<ul> <li>How do I read data directly from etcd?</li> <li>How do I encrypt secrets at rest?</li> </ul> </li> </ul> <p>NOTE: In the exam, you are advised to skip this question and come back to it at the end, as it is probably the hardest one and you don't want to waste time if there are easier questions further on!!</p>"},{"location":"information/etcd/#what-is-etcdctl_api3-all-about","title":"What is ETCDCTL_API=3 all about?","text":"<p><code>etcdctl</code> supports two versions of the server's API. When making server calls, it defaults to version 2 of the API, and in version 2 some operations are either undefined, or have different arguments. Setting this environment variable tells <code>etcdctl</code> to use the V3 API, which is required for the snapshot functionality.</p> <p>You may set the environment variable with each call...</p> <pre><code>ETCDCTL_API=3 etcdctl snapshot save ...\nETCDCTL_API=3 etcdctl snapshot restore ...\n</code></pre> <p>...or for the entire terminal session...</p> <pre><code>export ETCDCTL_API=3\netcdctl snapshot save ...\netcdctl snapshot restore ...\n</code></pre>"},{"location":"information/etcd/#when-do-i-use-endpoints","title":"When do I use --endpoints?","text":"<p>The <code>--endpoints</code> argument on <code>etcdctl</code> is used to tell it where to find the <code>etcd</code> server. If you are running the command on the same host where <code>etcd</code> service is running and there is only one instance of <code>etcd</code>, then you do not need to provide this argument, as it has a default value of <code>https://127.0.0.1:2379</code>.This is the case in most labs, as your prompt will nearly always be on the controlplane node.</p> <p>If you run <code>etcdctl</code> from a different workstation from where <code>etcd</code> is running, as may be the case in a production environment, or you need to use a non-standard port, then you need to provide this argument to say where the <code>etcd</code> server is. If you need to determine <code>host-ip</code> and/or <code>port</code> they can be found by looking at the etcd manifest (or systemd unit file when etcd is external) and finding this on the <code>--listen-client-urls</code> argument.</p> <ul> <li>Same host, different port: <code>--endpoints https://127.0.0.1:port</code></li> <li>Remote host: <code>--endpoints https://host-ip:port</code></li> </ul>"},{"location":"information/etcd/#what-are-all-the-certificates-used-for","title":"What are all the certificates used for?","text":"<p>When we take a backup, we have to pass three arguments related to certificates. This is because we must authenticate with the <code>etcd</code> server before it will divulge its sensitive data. The authentication scheme is called Mutual TLS (mTLS).</p> <p>This is an extension of what happens when you browse to an HTTPS web site. For web sites, that is one-way TLS where the web server must prove its identity to the browser before an encrypted channel is established. In mTLS, both ends must prove their identity to each other.</p> <p>Note that for restore on single <code>etcd</code> node clusters such as those found in the exam, it is not necessary to use the certificate arguments, since all the restore is doing is creating a directory. It does not need to communicate with the <code>etcd</code> server - which may even not be running if the exam deliberately sets it up with a corrupt database. You would only use certs and some additional arguments when restoring a broken node into what is left of a multi-node <code>etcd</code>, which is beyond the scope of CKA.</p>"},{"location":"information/etcd/#-cacert","title":"--cacert","text":"<ul> <li>This provides the path to the Certificate Authority (CA) certificate. The CA certificate is used to verify the authenticity of the TLS certificate sent to <code>etcdctl</code> by the <code>etcd</code> server. The server's certificate must be found to be signed by the CA certificate. When building a cluster, creating the CA is one of the tasks you need to do. <code>kubeadm</code> does it automatically, but to see how it is done manually (outside the scope of CKA exam), see kubernetes the hard way.</li> </ul>"},{"location":"information/etcd/#-cert","title":"--cert","text":"<ul> <li>This is the path to the TLS certificate that <code>etcdctl</code> sends to the <code>etcd</code> server. The <code>etcd</code> server will verify that this certificate is also signed by the same CA certificate. Certificates of this type contain a public key which can be used to encrypt data. The public key is used by the server to encrypt data being sent back to <code>etcdctl</code> during the authentication steps.</li> </ul>"},{"location":"information/etcd/#-key","title":"--key","text":"<ul> <li>This is the path to the private key that is used to decrypt data sent to <code>etcdctl</code> by the <code>etcd</code> server during the authentication steps. The key is only used by the <code>etcdctl</code> process. It is never sent to the server.</li> </ul> <p>For ease, you will find that normally both <code>etcdctl</code> and <code>etcd</code> share all three certificates, and these are the ones usually found in <code>/etc/kubernetes/pki/etcd</code>, however it is possible to issue <code>etcdtl</code> with its own certificate and key which is considered more secure, but that certificate must have been signed by the shared CA certificate.</p> <p>CA certificates are public knowledge. For HTTPS to work, your computer has copies of many well-known CA certificates, such as Comodo, DigiCert, GlobalSign etc. On Windows, these are located in the Trusted Root Certification Authorities section of the Certificate Manager application. When a web server passes its TLS certificate to the browser, it is these CA certificates it looks up to verify the identity of the web server.</p> <p>For a more detailed explanation of how mTLS works, see this page.</p>"},{"location":"information/etcd/#should-i-stop-api-server-andor-etcd-during-backup-or-restore","title":"Should I stop API server and/or etcd during backup or restore?","text":"<p>No</p> <p>Consider a production environment. In such environments, you would be making regular automated backups of etcd. If you stopped either of these processes, then the cluster could go offline, and you would be faced with a production major incident!</p> <p>etcd is designed to ensure consistency in its backups even while in use, just as you would expect from any regular SQL database.</p> <p>There may be some instances on a multi-node etcd cluster that it would be beneficial to stop everything to do a restore to ensure the database is not written before all nodes are aligned. In the CKA exam, all clusters are single-node etcd.</p>"},{"location":"information/etcd/#how-do-i-make-a-backup","title":"How do I make a backup?","text":"<p>In order to take a backup, there are several required arguments, as we need to authenticate with the server to pull any data from it. These are</p> <ul> <li><code>--cacert</code> - Path the the <code>etcd</code> CA certificate</li> <li><code>--cert</code> - Path to the <code>etcd</code> server certificate</li> <li><code>--key</code> - Path to the <code>etcd</code> server private key</li> <li><code>--endpoints</code> - Only required in certain circumstances. See this FAQ question.</li> </ul> <p>On <code>kubeadm</code> clusters such as the labs, killer.sh or the exam, these files should be found in <code>/etc/kubernetes/pki/etcd</code> on the control plane node, which is where you should run <code>etcdctl</code> unless instructed otherwise. A question may also tell you which certs to use, in which case adjust the following accordingly.</p> <p>Sample backup command</p> <pre><code>ETCDCTL_API=3 etcdctl snapshot save \\\n    --cacert /etc/kubernetes/pki/etcd/ca.crt \\\n    --cert /etc/kubernetes/pki/etcd/server.crt \\\n    --key /etc/kubernetes/pki/etcd/server.key \\\n    /opt/snapshot-pre-boot.db\n</code></pre>"},{"location":"information/etcd/#how-do-i-restore-a-backup","title":"How do I restore a backup?","text":"<p>Normally you will restore this to another directory, and then point the <code>etcd</code> service at the new location. For restores, the certificate and endpoints arguments are not required, as all we are doing is creating files in directories and not talking to the <code>etcd</code> API, so the only argument required is <code>--data-dir</code> to tell <code>etcdctl</code> where to put the restored files.</p> <p>What needs to be done following the restore to get <code>etcd</code> to use it depends on how the cluster is deployed.</p> <p>Sample restore command</p> <pre><code>ETCDCTL_API=3 etcdctl snapshot restore \\\n    --data-dir /var/lib/etcd-from-backup \\\n    /opt/snapshot-pre-boot.db\n</code></pre>"},{"location":"information/etcd/#kubeadm-clusters-with-etcd-running-as-a-pod","title":"kubeadm clusters with etcd running as a pod","text":"<p>This is known as \"stacked etcd\"</p> <p>It is a change to a single line in the manifest.</p> <p>Determine that the cluster is configured this way by executing the following and determining that <code>etcd</code> is in the results</p> <pre><code>kubectl get pods -n kube-system\n</code></pre> <p>Now do the following on the control node.</p> <ol> <li>Edit the manifest file for <code>etcd</code> on the controlplane node. This is found in <code>/etc/kubernetes/manifests/etcd.yaml</code>.</li> <li>Scroll down to the <code>volumes</code> section and find the volume that describes the data directory (see below).</li> <li>Edit the <code>hostPath.path</code> of the volume with name <code>etcd-data</code> from <code>/var/lib/etcd</code> to <code>/var/lib/etcd-from-backup</code> (or whichever directory you used for the restore command). Note that you do not change the <code>--data-dir</code> command line argument to <code>etcd</code> in the container's command specification.</li> <li>Wait about a minute for everything to reload.</li> </ol> <p>This is the section in <code>etcd.yaml</code> that you need to find...</p> <pre><code>  volumes:\n  - hostPath:\n      path: /etc/kubernetes/pki/etcd\n      type: DirectoryOrCreate\n    name: etcd-certs\n  - hostPath:\n      path: /var/lib/etcd    # &lt;- change this\n      type: DirectoryOrCreate\n    name: etcd-data\n</code></pre> <p>Why does this work? You need to remember how mounting volumes in containers works.</p> <ul> <li><code>volumes.hostPath.path</code> which you edited above specifies the directory on the node (host) where the data is stored. This is the actual location of where the backup was restored to.</li> <li><code>containers.volumeMounts.mountPath</code> specifies the directory inside the container where the host data is mounted. We haven't changed that. From the <code>etcd</code> container's point of view, the directory is still <code>/var/lib/etcd</code>.</li> </ul> <p>And note...</p> <pre><code>  containers:\n  - command:\n    - etcd\n    - --advertise-client-urls=https://10.40.10.9:2379\n    - --cert-file=/etc/kubernetes/pki/etcd/server.crt\n    - --client-cert-auth=true\n    - --data-dir=/var/lib/etcd                  # &lt;- DO NOT CHANGE THIS!\n    - --initial-advertise-peer-urls=https://10.40.10.9:2380\n    - --initial-cluster=controlplane=https://10.40.10.9:2380\n</code></pre>"},{"location":"information/etcd/#troubleshooting-after-the-restore","title":"Troubleshooting after the restore","text":"<p>It can take up to 60 seconds for service to resume after you have edited the <code>etcd</code> manifest. You may observe the progress of the pod restarts by running the following command. As mentioned above, give it up to 60 seconds to become stable.</p> <pre><code>watch crictl ps\n</code></pre> <p>This will show you the running containers, refreshing the list every two seconds. You are waiting for the following to be stable:</p> <pre><code>Every 2.0s: crictl ps                                                                                                                                    controlplane: Thu Jan 26 01:50:48 2023\n\nCONTAINER           IMAGE               CREATED             STATE               NAME                      ATTEMPT             POD ID              POD\nc6e61480ac614       a31e1d84401e6       9 minutes ago       Running             kube-apiserver            6                   2623ac5d1b43b       kube-apiserver-controlplane\n629d81d592938       fce326961ae2d       10 minutes ago      Running             etcd                      0                   87710b3c9a99a       etcd-controlplane\n3715d4173cc9f       5d7c5dfd3ba18       15 minutes ago      Running             kube-controller-manager   1                   bd8758b9de774       kube-controller-manager-controlplane\nb182a4a2ba76d       dafd8ad70b156       15 minutes ago      Running             kube-scheduler            1                   3359954829552       kube-scheduler-controlplane\ne431a0ba0c04d       5185b96f0becf       23 minutes ago      Running             coredns                   0                   8d65a558ea93d       coredns-787d4945fb-2jn9w\nb8e8d94ea1074       5185b96f0becf       23 minutes ago      Running             coredns                   0                   7dc120679094d       coredns-787d4945fb-xj4ll\nfc30b4a42a287       8b675dda11bb1       23 minutes ago      Running             kube-proxy                0                   d73933f8fac41       kube-proxy-b9cv2\n</code></pre> <p>All the containers must be stable, i.e. not flipping on and off the list and <code>ATTEMPT</code> value should stop increasing. There may be other containers, but the ones in this list are the important ones. To get out of this display, press <code>CTRL-C</code>. Now you should be able to run <code>kubectl</code> commands again.</p> <p>If the <code>etcd</code> pod does not come back up in a reasonable time, you can troubleshoot the same way as for apiserver.</p>"},{"location":"information/etcd/#clusters-with-external-etcd","title":"Clusters with external etcd","text":"<p>This covers both <code>kubeadm</code> clusters where <code>etcd</code> is not running as a pod, and fully manual installations like kubernetes the hard way.</p> <p>Some people have suggested that this is how some of the <code>etcd</code> questions the exam question bank are set up, as in you have to do it all from some node other than the control node for the target cluster. It requires a bit more work, but it doesn't mean that you will definitely get a question that is this way and not stacked-mode as above!</p> <p>If you do find that your backup/restore question is an External etcd, then definitely flag the question and leave it till last!</p> <p>On the node where you are instructed to do the task, first become root, if you are not already root.</p> <pre><code>sudo -i\n</code></pre> <p>Next, determine how many <code>etcd</code> processes there are</p> <pre><code>ps -aux | grep etcd\n</code></pre> <p>The output looks like this</p> <p>etcd\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0804\u00a0\u00a0\u00a0\u00a00.0  0.0 11217856 46296 ?      Ssl  10:10   0:08 /usr/local/bin/etcd --name etcd-server --data-dir=/var/lib/etcd-data --cert-file=/etc/etcd/pki/etcd.pem --key-file=/etc/etcd/pki/etcd-key.pem --peer-cert-file=/etc/etcd/pki/etcd.pem --peer-key-file=/etc/etcd/pki/etcd-key.pem --trusted-ca-file=/etc/etcd/pki/ca.pem --peer-trusted-ca-file=/etc/etcd/pki/ca.pem --peer-client-cert-auth --client-cert-auth --initial-advertise-peer-urls https://10.21.18.18:2380 --listen-peer-urls https://10.21.18.18:2380 --advertise-client-urls https://10.21.18.18:2379 <code>--listen-client-urls https://10.21.18.18:2379,https://127.0.0.1:2379</code> --initial-cluster-token etcd-cluster-1 --initial-cluster etcd-server=https://10.21.18.18:2380 --initial-cluster-state new root\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01106\u00a0\u00a0\u00a0\u00a00.0  0.0  13448  1064 pts/0    S+   10:17   0:00 grep etcd</p> <p>In the above, there is one instance of <code>etcd</code> running. If there were more, then you would see additional big blocks of <code>etcd</code> arguments. It should be highly unusual to be faced with more than one <code>etcd</code> running on the same host in the exam. If you have seen more than one <code>etcd</code>, please post in the slack channel. Don't include full details of the question, as that would violate NDA. Only state that you have seen multiple external etcd processes.</p> <p>In the exam, use the <code>mousepad</code> application to take notes.</p>"},{"location":"information/etcd/#single-etcd-process","title":"Single etcd process","text":"<ol> <li>Note down the port number from <code>--listen-client-urls</code>. It will be unusual (not impossible) if it is something other than <code>2379</code></li> <li> <p>Determine the name of the <code>etcd</code> service unit. Note that the service unit files end with <code>.service</code>. When referring to a service uint with <code>sysemctl</code> commands, it is not necessary to type <code>.service</code> - it is assumed, therefore less typing!</p> <p><code>bash systemctl list-unit-files | grep etcd</code></p> <p>Output will be like</p> <p><code>etcd.service                               enabled         enabled</code> 1. If the location of the service unit file has not been given in the question, then you must locate it. You will need to edit it later if you have to do a restore.</p> <p><code>bash systemctl cat etcd</code></p> <p>Output (some lines truncated. Important lines are shown)</p> <p>```bash   # /etc/systemd/system/etcd.service   [Unit]   Description=etcd   Documentation=https://github.com/coreos</p> <p>[Service]   ExecStart=/usr/local/bin/etcd \\   --- truncated---     --listen-client-urls https://192.168.56.11:2379,https://127.0.0.1:2379   --- truncated---     --data-dir /var/lib/etcd   ```</p> <ul> <li>Note the first line which is a comment. This is the full path to the file. Note it down, you will need to edit this file later if doing a restore.</li> <li>Note also the values for <code>--listen-client-urls</code></li> </ul> </li> <li> <p>If you have been instructed to take a backup, then you should have been given the path to the certificates to use with <code>etcdctl</code>. If you have only been given a directory name, rather than all three certificates, do an <code>ls -l</code> of this directory to determine the certificate/key names.For instance, if the directory given is <code>/etc/etcd/pki</code> and you find this contains <code>ca.crt</code>, <code>server.crt</code> and <code>server.key</code> then the command would be</p> <p><code>bash ETCDCTL_API=3 etcdctl snapshot save \\   --cacert /etc/etcd/pki/ca.crt \\   --cert /etc/etcd/pki/server.crt \\   --key /etc/etcd/pki/server.key \\   /path/to/snapshot.db</code></p> <p>Note that if the port number on <code>--listen-client-urls</code> is not 2379, then you also require <code>--endpoints</code></p> </li> <li> <p>If you have been instructed to do a restore then</p> <ol> <li> <p>Determine the ownership of the original data directory as found in the unit file above at <code>--data-dir</code></p> <p><code>bash ls -ld /var/lib/etcd</code></p> <p>Output - here we see it is owned by <code>etcd:etcd</code></p> <pre><code>drwx------ 3 etcd etcd 4096 Nov 28 01:18 /var/lib/etcd\n</code></pre> </li> <li> <p>Do the restore to whichever directory instructed by the question. For instance, if it is <code>/var/lib/etcd-from-backup</code> then</p> <p><code>bash ETCDCTL_API=3 etcdctl snapshot restore \\   --data-dir /var/lib/etcd-from-backup \\   /path/to/snapshot.db</code></p> </li> <li> <p>If the original data directory was not owned by root, set the ownership of the newly created directory to the correct user:group</p> <p><code>bash chown -R etcd:etcd /var/lib/etcd-from-backup</code></p> </li> <li> <p>Now edit the system uint file with <code>vi</code> using the path you noted above and set <code>--data-dir</code> to where you did the restore, e.g. <code>/var/lib/etcd-from-backup</code></p> <p><code>bash vi /etc/systemd/system/etcd.service</code></p> </li> <li> <p>Restart the <code>etcd</code> service</p> <p><code>bash systemctl daemon-reload systemctl restart etcd</code></p> </li> </ol> </li> </ol>"},{"location":"information/etcd/#multiple-etcd-processes","title":"Multiple etcd processes","text":"<p>It is highly unlikely you will find this configuration, but if you do, please report it in the slack channel.</p> <p>If there's more than one, you need to identify the correct one! In the output of the above <code>ps -aux | grep etcd</code> command, you should be able to see the <code>--listen-client-urls</code> argument. Note down the port numbers from this URL for each <code>etcd</code> process.</p> <ol> <li> <p>Go onto the control node for the target cluster and run</p> <ul> <li> <p>If it is a kubeadm cluster (api server is running as a pod). It should be like this in the exam.</p> <p><code>grep etcd-servers /etc/kubernetes/manifests/kube-apiserver.yaml</code></p> </li> <li> <p>If it is not kubeadm, and api server is an operating system service</p> </li> </ul> <p><code>sudo ps -aux | grep apiserver</code></p> <p>Find <code>--etcd-servers</code> in the argument list and note the port number. You need to match that with one of the port numbers you've noted down above. That will get you the correct <code>etcd</code> process.</p> <p>Log out of the control node and return to the node running <code>etcd</code>. When you get there, remember to do <code>sudo -i</code> again if needed.</p> </li> <li> <p>Next, find the unit file for the correct <code>etcd</code> service. The following will give you the file names.</p> <p><code>bash systemctl list-unit-files | grep etcd</code></p> <p>Output will be something like</p> <pre><code>```\netcd-1.service                               enabled         enabled\netcd-2.service                               enabled         enabled\n```\n</code></pre> </li> <li> <p>To locate these files, run the following on each filename returned by the command above</p> <p><code>bash systemctl cat etcd-1 systemctl cat etcd-2</code></p> <p>Refer to above sections for what the output looks like. Find the correct one by examining each identified unit file and choose the one that has the matching port number for the <code>--listen-client-urls</code> argument. You will need to edit this later if doing a restore.</p> </li> <li> <p>If you have been instructed to take a backup, then identify the certificates as per instructions for single etcd above and form the backup command in the same way, but additionally specify <code>--endpoint CLIENT_URL</code> where <code>CLIENT_URL</code> is the URL from the<code>--listen-client-urls</code> in the identified unit file. Choose the <code>https://127.0.0.1:...</code> URL if present.</p> </li> <li> <p>If you have been instructed to do a restore</p> <ol> <li>Perform the same steps as for single etcd to form the restore command, and to set directory ownership.</li> <li>Edit the correct service unit file identified above and set the new <code>--data-dir</code></li> <li>Restart the identified service with <code>systemctl daemon-reload</code> and <code>systemctl restart</code></li> </ol> </li> </ol> <p>Please also try the following lab for practice of external etcd</p> <p>https://kodekloud.com/topic/practice-test-backup-and-restore-methods-2-2/</p>"},{"location":"information/etcd/#advanced-usage","title":"Advanced Usage","text":"<p>This section contains topics that may come up in CKS exam. You do not need to know this for CKA.</p>"},{"location":"information/etcd/#how-do-i-read-data-directly-from-etcd","title":"How do I read data directly from etcd?","text":"<p>You may get a question that asks you to get data directly from the etcd database, for instance the content of a secret.</p> <p>ETCD in Kubernetes stores data under <code>/registry/{type}/{namespace}/{name}</code>.</p> <p>Thus, if you were looking for a <code>secret</code> called <code>database-access</code> in namespace <code>team-green</code>, the key path would be</p> <pre><code>/registry/secrets/team-green/database-access\n</code></pre> <p>To read this data, you would run the following <code>get</code> command</p> <pre><code>ETCDCTL_API=3 etcdctl \\\n  --cacert /etc/kubernetes/pki/etcd/ca.crt \\\n  --cert /etc/kubernetes/pki/apiserver-etcd-client.crt \\\n  --key /etc/kubernetes/pki/apiserver-etcd-client.key \\\n  get /registry/secrets/team-green/database-access\n</code></pre> <p>The same rules discussed above apply to the use of <code>--endpoints</code></p>"},{"location":"information/etcd/#how-do-i-encrypt-secrets-at-rest","title":"How do I encrypt secrets at rest?","text":"<p>Secrets are more or less human readable when stored in etcd. To store them in an encrypted form you need to create an encryption configuration file, then update the API server manifest to make use of it. The steps to do this are detailed here.</p> <p>Once the configuration is properly applied, you can encrypt existing secrets by replacing them.</p> <p>All secrets in the cluster</p> <pre><code>kubectl get secrets --all-namespaces -o json | kubectl replace -f -\n</code></pre> <p>A single namespace</p> <pre><code>kubectl get secrets -n some_namespace -o json | kubectl replace -f -\n</code></pre> <p>A single secret</p> <pre><code>kubectl get secrets my_secret -o json | kubectl replace -f -\n</code></pre> <p>In our kubernetes the hard way labs, we enable secret encryption at rest by default.</p>"},{"location":"information/vi-101/","title":"vi-101","text":"<p>Source: https://github.com/kodekloudhub/community-faq/blob/main/docs/vi-101.md</p> <p>IMPORTANT - The <code>vimium</code> chrome extension is known to cause issues with using vi in lab terminals due to the fact that it intercepts the keystrokes that the vi editor is expecting. The whole point of this extension is to use vi commands to drive the browser itself, therefore the vi inside the browser will never receive the commands!If you have this extension, please disable it.</p> <p>Real simple guide to the most important stuff with <code>vi</code> editor and questions commonly asked</p> <ul> <li>I cannot type anything!</li> <li>I cannot exit vi</li> <li>Modes</li> <li>Most useful normal mode commands<ul> <li>Files</li> <li>Editing</li> </ul> </li> <li>Suggested settings for YAML editing</li> </ul>"},{"location":"information/vi-101/#i-cannot-type-anything","title":"I cannot type anything!","text":"<p>Probably the first time you've used <code>vi</code> right? When you start the editor, it is in what is known as <code>normal</code> mode, which is a command entry mode. Certain keystrokes will be interpreted as commands, others may be ignored. What won't be happening is text is being typed into the editor.</p> <p>To begin editing, you must enter <code>insert</code> mode, by typing <code>i</code>. If you've typed some other keys in confusion, this may not work immediately. Press <code>ESC</code> then press <code>i</code>. The bottom line of the editor should read <code>--INSERT--</code>. Now you can edit stuff.</p>"},{"location":"information/vi-101/#i-cannot-exit-vi","title":"I cannot exit vi","text":"<p>Some possibilities.</p> <ol> <li> <p>You are not in <code>normal</code> mode.</p> <p>You need to be in <code>normal</code> mode to execute any of the commands to exit the editor. If it says <code>INSERT</code>, <code>VISUAL</code> or anything like that at the bottom of the screen, press <code>ESC</code> until it no longer does.</p> <p>Then you should be able to press <code>:</code> and see it come up at the bottom of the screen, so you're able to enter something like <code>wq</code></p> </li> <li> <p>You are editing a read-only file.</p> <p>You get a message like <code>E505 \"file\" is read only (add ! to override)</code> when you try <code>:wq</code>.</p> <p>The message is encouraging you to do <code>:wq!</code> to force overwrite of a read-only file, but if that file belongs to root and you are not root, then this isn't going to work and you'll get the same error. The only way to exit in this case is to exit without saving, which is <code>:q!</code>. For root owned files, you must use <code>sudo</code>, e.g.</p> <p><code>sudo vi /etc/hosts</code></p> <p>Note that in Kubernetes labs, you are already the root user so you'll never need <code>sudo</code>. In Linux labs, you are never the root user when the lab starts, and you'll need <code>sudo</code> a lot!</p> </li> </ol>"},{"location":"information/vi-101/#modes","title":"Modes","text":"<p>The editor has several modes. It operates differently in each mode.</p>"},{"location":"information/vi-101/#normal-mode","title":"Normal mode","text":"<p>This is the mode that you are in when you first start vi. It is a command mode, therefore most key strokes are interpreted as editor commands. Some useful commands are detailed further down.</p> <p>Pressing the <code>ESC</code> key when in any other mode returns you to Normal mode.</p>"},{"location":"information/vi-101/#insert-mode","title":"Insert mode","text":"<p>In this mode you can edit text in the document. It should say <code>-- INSERT --</code> at the bottom of the screen.</p> <p>To enter Insert mode, hit <code>i</code> when in Normal mode</p>"},{"location":"information/vi-101/#visual-mode","title":"Visual Mode","text":"<p>In this mode you can select blocks of text on which to operate. Use normal mode commands to operate on the selected text. There are 3 flavours of this:</p> <ul> <li>Visual - This mode allows you to select text character by character using cursor keys. It will say <code>-- VISUAL --</code> at the bottom of the screen. Press <code>v</code> when in normal mode to enter.</li> <li>Visual Line - This mode allows you to select entire lines. It will say <code>-- VISUAL LINE --</code> at the bottom of the screen. Press <code>SHIFT-V</code> when in normal mode to enter.</li> <li>Visual Block - This mode allows you to select blocks of text horizontally and vertically. It will say <code>-- VISUAL BLOCK --</code> at the bottom of the screen. Press <code>CTRL-V</code> when in normal mode to enter.</li> </ul>"},{"location":"information/vi-101/#most-useful-normal-mode-commands","title":"Most useful normal mode commands","text":"<p>All the following work in <code>normal</code> mode. As soon as you enter insert mode, you need to press <code>ESC</code> before any of the following will work again.</p>"},{"location":"information/vi-101/#files","title":"Files","text":"<ul> <li> <p>Saving without exiting</p> <ul> <li><code>:w</code> - When editing Kubernetes YAML in the exam, do this and run <code>kubectl apply</code> in another terminal window. Saves you going in and out the editor if you have syntax errors. Only quit <code>vi</code> once <code>kubectl</code> is successful.</li> </ul> </li> <li> <p>Exit without saving</p> <ul> <li><code>:q!</code></li> </ul> </li> <li> <p>Exit and save</p> <p>Both these commands achieve the same thing. 1. <code>:wq</code> 1. <code>:x</code></p> </li> <li> <p>Pasting from documentation</p> <ul> <li><code>:set paste</code> - Turn on paste mode. Then hit <code>i</code> for insert mode. It will say <code>INSERT (paste)</code></li> <li><code>:set nopaste</code> - Turn off paste mode. Do this immediately after pasting from documentation.</li> </ul> </li> </ul>"},{"location":"information/vi-101/#editing","title":"Editing","text":"<ul> <li><code>i</code> - Enter insert mode at cursor position</li> <li><code>SHIFT - A</code> - Enter insert mode at end of current line</li> <li><code>y</code> - Yank (copy) current line to vi internal buffer (not desktop clipboard)</li> <li><code>p</code> - Paste from vi internal buffer. It will paste below not at the line the cursor is on.</li> <li><code>dd</code> - Delete (cut) line under cursor. (<code>2dd</code> next 2 lines, <code>5dd</code> next 5 lines etc.). Lines removed this way are placed in vi internal buffer, i.e. can be pasted.</li> <li><code>u</code> - Undo last edit (<code>2u</code> last 2 edits etc.)</li> <li><code>r</code> - Replace character under the cursor. Press <code>r</code> followed by the character you want to put in. It will replace the character that the cursor is on.</li> <li><code>SHIFT + D</code> - Delete from cursor to end of line</li> <li><code>gg</code> - Go to top of file</li> <li><code>SHIFT + G</code> - Go to last line in file</li> <li><code>&gt;</code> - Indent current line one tab stop. (<code>.</code> indent again)</li> <li><code>&lt;</code> - Outdent current line one tab stop. (<code>.</code> outdent again)</li> <li><code>SHIFT + V</code> - Enter visual line mode. You can select multiple lines of text and perform operations like <code>dd</code>, <code>y</code>, <code>&gt;</code>, <code>&lt;</code> on the selected lines</li> </ul>"},{"location":"information/vi-101/#line-numbers","title":"Line Numbers","text":"<p>There are a couple of modes for showing line numbers in the editor. Generally you'll want to show line numbers so that when an error message from some command refers to a line number in a file you're processing, you can find it. You change the line number mode from <code>normal</code> mode using <code>:</code> commands.</p>"},{"location":"information/vi-101/#absolute-numbers","title":"Absolute numbers","text":"<p>This mode numbers the lines normally starting with 1 as the first line of the file.</p> <p>Turn on/off with <code>:set nu</code>/<code>:set nonu</code></p>"},{"location":"information/vi-101/#relative-numbers","title":"Relative numbers","text":"<p>This mode shows numbers relative to where the cursor is positioned, so line 1 is the line directly following the cursor. This mode is especially useful for finding an error in a Kubernetes manifest containing multiple resource documents.</p> <p>Turn on/off with  <code>:set rnu</code>/<code>:set nornu</code></p> <p>See examples of these modes in action here</p>"},{"location":"information/vi-101/#suggested-settings-for-yaml-editing","title":"Suggested settings for YAML editing","text":"<p>Create a file <code>~/.vimrc</code> and add the following lines to it.</p> <pre><code>set nu\nset sw=2\nset et\nset ts=2\nset ai\n</code></pre> <p>What these do, in order:</p> <ol> <li>Enable line numbers</li> <li> <p>Set shift width 2 chars</p> <p>Note: May already be configured on exam terminal</p> </li> <li> <p>Expand tabs to spaces</p> <p>Note: May already be configured on exam terminal</p> </li> <li> <p>Set tab stop to 2 chars</p> <p>Note: May already be configured on exam terminal</p> </li> <li> <p>Enable auto indent</p> </li> </ol>"},{"location":"information/yaml-faq/","title":"YAML FAQ","text":"<p>Source: https://github.com/kodekloudhub/community-faq/blob/main/docs/yaml-faq.md</p> <p>We see a few questions about \"kubectl\" YAML manifests and what you can and can't do syntactically, therefore we'll try to clear some of this up.</p> <p><code>kubectl</code> (and anything else in the ecosystem that needs to read YAML like <code>kubelet</code> etc) is built using the standard GoLang YAML package, which apart from anything explicitly mentioned in the package's Compatibility paragraph is generally YAML 1.2 compliant (see gotchas below), and this is the dialect that <code>kubectl</code> understands. There is no \"special\" <code>kubectl</code> dialect.</p> <ul> <li>In a nutshell</li> <li>To quote or not to quote</li> <li>Indentation</li> <li>Dealing with Errors (kubectl)</li> <li>Gotchas</li> <li>YAML Practice lab</li> <li>Advanced features<ul> <li>Documents</li> <li>Aliases and anchors</li> </ul> </li> </ul>"},{"location":"information/yaml-faq/#in-a-nutshell","title":"In a nutshell","text":"<p>YAML is a superset of JSON and has all the same concepts like objects (a.k.a. dictionary, map) and lists, and combinations of all these</p> <pre><code>myString: I am a string value\nmyNumber: 123\nmyBoolean: true\nmyList:\n- value1\n- value2\n- valuen\nmyObject:           # Every key-value indented beneath here is part of `myObject` dictionary\n  property1: value1\n  property2: value2\n  propertyn: valuen\n</code></pre> <p>Every item is a key-value pair, where the key name ends with a <code>:</code> and the value follows.</p> <p>A value may be of any valid type; a scalar (string, number, bool etc.), or a list or another object, so <code>value1</code>, <code>value2</code>, <code>valuen</code> above can be any of these types, however here they are string literals.</p> <p>This is exactly the same as this JSON</p> <pre><code>{\n    \"myString\": \"I am a string value\",\n    \"myNumber\": 123,\n    \"myBoolean\": true,\n    \"myList\": [\n        \"value1\",\n        \"value2\",\n        \"valuen\"\n    ],\n    \"myObject\": {\n        \"property1\": \"value1\",\n        \"property2\": \"value2\",\n        \"propertyn\": \"valuen\"\n    }\n}\n</code></pre> <p>Any valid JSON is also valid YAML, meaning you can mix and match</p> <pre><code># Using JSON array for command parameters (known as YAML flow style)\ncommand: [\"sleep\", \"4800\"]\n</code></pre> <p>is equivalent to</p> <pre><code># Using YAML array for command parameters (known as YAML block style)\ncommand:\n- sleep\n- \"4800\"\n</code></pre> <p>In places where you need to declare an empty YAML object key, then you must use flow style to represent the value as an empty (JSON) object, such as</p> <pre><code>volumes:\n- name: my-volume\n  emptyDir: {}\n</code></pre> <p>This is because to put nothing after <code>emptyDir:</code> would be a syntax error as the value would be missing. What we are doing is asking for an <code>emptyDir</code> volume with no custom properties. There are properties that could be used with this but they are beyond the scope of the exams.</p>"},{"location":"information/yaml-faq/#to-quote-or-not-to-quote","title":"To quote or not to quote","text":"<p>YAML always parses literal values as strings, unless the value is wholly numeric (including canonical, integer, fixed point, exponential, octal or hex), a timestamp or a boolean (<code>true</code>, <code>false</code>). If you want to force a non-string to be parsed as a string, you must quote it. This rule applies to environment variable values and to command arguments which must both be passed to the underlying container as a string, hence</p> <pre><code>command:\n- sleep\n- \"4800\"\n</code></pre> <p>If you are creating configmaps or secrets for use with environment variables, the same quoting rules apply.</p> <p>We've seen posts that say \"You must quote mount paths\" or \"You must quote pod capabilities\". This is not the case. The rules are as stated above. At the end of the day you want to use as few keystrokes as possible when doing the exam! You only need to quote in flow-style e.g.</p> <pre><code>    securityContext:\n      capabilities:\n        add: [\"NET_ADMIN\", \"SYS_TIME\"]\n</code></pre> <p>is exactly the same as</p> <pre><code>    securityContext:\n      capabilities:\n        add:\n        - NET_ADMIN\n        - SYS_TIME\n</code></pre>"},{"location":"information/yaml-faq/#indentation","title":"Indentation","text":"<p>Beware of the pesky indentation rules. Whitespace is part of the syntax like Python, however <code>TAB</code> characters are not. Each indentation level should be two spaces. If you mess this up you can get all kinds of different errors from <code>kubectl</code> depending on where it was in the file when it encountered the error.</p> <p>Lists may be introduced at the same level as the parent key, or indented. Both the following lists are valid</p> <pre><code>list1:\n- value1\n\nlist2:\n  - value2\n</code></pre> <ul> <li>Make sure vim is not inserting <code>TAB</code> instead of spaces, or you will get cryptic errors from <code>kubectl</code>!</li> <li>Remember to use <code>INSERT (paste)</code> mode when pasting YAML from documentation, and toggle paste mode OFF before hitting tab on the keyboard.</li> </ul> <p>The following vim settings in .vimrc work for me, but many people have posted other settings in blogs like Medium.</p> <pre><code>set nu\nset ts=2\nset sw=2\nset et\nset ai\nset pastetoggle=&lt;F3&gt;\n</code></pre> <p>What these do, in order:</p> <ol> <li>Enable line numbers</li> <li>Set shift width 2 chars</li> <li>Expand tabs to spaces</li> <li>Set tab stop to 2 chars</li> <li>Enable auto indent</li> <li>NOTE - this was not working properly in the exam as of 2022-07-06. See Issues with Exam Portal.Set F3 key to toggle paste mode. This is super important when pasting from the Kubernetes docs. Enter insert mode <code>i</code> then press <code>F3</code> so the bottom line reads<code>INSERT (paste)</code>Once you've pasted, ensure to toggle paste mode OFF again, or <code>TAB</code> key will start inserting tab characters and <code>kubectl</code> will complain!</li> </ol> <p>Paste mode may also be toggled from vi normal mode with the following commands:</p> <ul> <li><code>:set paste</code></li> <li><code>:set nopaste</code></li> </ul>"},{"location":"information/yaml-faq/#dealing-with-errors-kubectl","title":"Dealing with errors (kubectl)","text":"<p>When a manifest is read, it is a two-pass operation</p> <ol> <li> <p>The YAML is read in and converted to JSON. In this phase, errors specific to the grammar of YAML itself will be detected. If it gets past this phase, then the YAML is syntactically correct as far as YAML grammar goes. These errors have line number context and will be shown as</p> <p><code>(yaml: line #: error message)</code></p> <p>You should enable line numbers in <code>vi</code> to help you get to these errors quickly. If line numbers are not showing, enter <code>:set nu</code> into <code>vi</code> before entering insert mode.</p> <p>If the manifest file being read has multiple documents, then the error line number is relative to the beginning of the document currently being read, not the beginning of the file. You can use relative line numbers in vi to get to the correct line of a document further down the manifest file.</p> </li> <li> <p>Once the YAML has successfully been converted to JSON, then the JSON is marshalled to Go structures internally (i.e. the programmatic representation of pods, deployments, etc.). These errors are generally of the form</p> <p><code>(json: cannot unmarshal _something_ into Go _something_else_ of type _sometype_)</code></p> <p>This means that you have probably missed a key, or put a list or a string literal where there should have been a map. Basically what you've put for a pod is syntactically correct YAML, but that YAML does not correctly represent a pod.You can get a clue as to where the error is from the <code>something_else</code>. Say that is <code>PodSpec.spec.containers</code> then it's in the <code>containers:</code> section of the manifest. Say it's <code>Volume.spec.volumes.hostPath</code> then it's a <code>hostPath:</code> within one of your <code>volumes:</code>.</p> <p>Essentially you have supplied the wrong data type at the manifest path indicated by something_else. You can use this information in a <code>kubectl explain</code> to find out what should be there, so for the above <code>PodSpec.spec.containers</code>:</p> <ol> <li>From the something_else omit the first <code>Spec</code> (if present and has capital S), then lowercase what remains, e.g. <code>PodSpec</code> = <code>pod</code>, <code>PersistentVolumeSpec</code> = <code>persistentvolume</code>.</li> <li> <p>Make an explain command</p> <p><code>kubectl explain pod.spec.containers</code></p> </li> </ol> </li> </ol> <p>A manifest parse stops at the first error encountered, as it loses context and cannot continue. This means if you have made multiple errors you have to fix one to be able to find the next, therefore getting it right is an iterative process!</p> <p>Some common errors you'll get from Kubernetes components when your YAML is malformed are shown below. I'm showing the relevant portion of the error messages:</p> <ul> <li> <p>TABs</p> <p><code>(yaml: line 67: found character that cannot start any token)</code></p> <p>Usually indicative of <code>TAB</code> characters found where there should be spaces at the given line.</p> </li> <li> <p>Incorrect indention causing map when list is expected</p> <p><code>(yaml: line 56: mapping values are not allowed in this context)</code></p> <p>Here the error is caused by</p> <p><code>yaml spec:   containers:   name: nginx     # &lt;- line 56</code></p> <p><code>name</code> is not an allowed key for <code>spec</code>, which is how we've put it. <code>name</code> is actually part of a container definition and <code>containers</code> is a list of container defintions. Should have been</p> <p><code>yaml spec:   containers:   - name: nginx</code> * Unknown field</p> <p><code>Error from server (BadRequest): error when creating \"some-pod\": Pod in version \u201cv1\u201d cannot be handled as a Pod: strict decoding error: unknown field \u201cspec.containers[0].dnsPolicy\u201d</code></p> <p>Again, usually an indentation problem (in this case), or it really is a field that doesn't exist e.g. you put <code>foobar</code> or some other nonsense, or you simply typoed the key name.</p> <p><code>yaml apiVersion: v1 kind: Pod metadata:   name: test spec:   containers:   - image: busybox     name: test     command:     - sleep     - \u201c1800\u201d     dnsPolicy: ClusterFirst  #&lt;- This is indented too far</code></p> <p>In the example above <code>dnsPolicy</code> has been indented to be part of the first container (i.e. <code>containers[0]</code>), and as such is an unknown field for a container specification. It should be part of <code>spec</code> for the pod itslf.</p> </li> <li> <p>Could not find expected key</p> <p><code>(yaml: line 106: did not find expected key)</code></p> <p>Most likely you inserted a new list item somewhere near the given line, but did not specify it as a list item, e.g.</p> <p><code>yaml   volumes:     hostPath:                    # &lt;- you inserted this volume       path: /etc/ssl/certs       type: DirectoryOrCreate     name: ca-certs   - hostPath:       path: /etc/ca-certificates       type: DirectoryOrCreate     name: etc-ca-certificates</code></p> <p>But you forgot the <code>-</code></p> <p><code>yaml   volumes:   - hostPath:                    # &lt;- note the difference       path: /etc/ssl/certs       type: DirectoryOrCreate     name: ca-certs   - hostPath:       path: /etc/ca-certificates       type: DirectoryOrCreate     name: etc-ca-certificates</code></p> </li> <li> <p>Missing list where Kubernetes expects one</p> <p><code>(json: cannot unmarshal object into Go struct field PodSpec.spec.containers of type []v1.Container)</code></p> <p>Any unmarshalling error that mentions <code>type []...</code> (doesn't matter what comes after <code>[]</code>) means that a YAML list was expected but not found. In this particular case, it is telling us <code>PodSpec.spec.containers</code>, so it is complaining about the <code>containers:</code> section in your pod defintion not being a list. That means you probably did something like</p> <p><code>yaml spec:   containers:     name: nginx     image: nginx</code></p> <p>When it should be</p> <p><code>yaml spec:   containers:   - name: nginx     image: nginx</code></p> </li> <li> <p>Missing map where Kubernetes expects one</p> <p><code>(json: cannot unmarshal string into Go struct field Volume.spec.volumes.hostPath of type v1.HostPathVolumeSource)</code></p> <p>In this case, the error is caused by</p> <p><code>yaml volumes: - hostPath: /tmp</code></p> <p>We have specified a string <code>/tmp</code> for the value of <code>hostPath</code> when a YAML map is expected. These are represented as Go <code>struct</code> internally.</p> <p>It should have been</p> <p><code>yaml volumes: - hostPath:     path: /tmp</code></p> </li> <li> <p>Argument error</p> <p>The YAML is correct. The spec structure is correct after it's been converted to JSON and marshalled, however the argument to a spec property is invalid.</p> <p>For instance, you've created a <code>volume</code> with type <code>File</code> or <code>Directory</code> which means that the indicated path must exist. If it does not, you will get an error similar to</p> <p><code>Error: MountVolume.SetUp failed for volume \"audit\" (UniqueName: \"kubernetes.io/host-path/5a5fb26ce98b248d1257ea78eeb44853-audit\") pod \"kube-apiserver-controlplane\" (UID: \"5a5fb26ce98b248d1257ea78eeb44853\") : hostPath type check failed: /etc/kubernetes/dev-audit.yaml is not a file</code></p> </li> </ul> <p>In general the categories of error fall under</p> <ul> <li>Incorrect indentation</li> <li>Misspelled or missing key</li> <li>Array when it should have been map</li> <li>Map when it should have been array</li> <li>Argument errors</li> </ul> <p>EXAM TIP</p> <p>While debugging a YAML file, have <code>vi</code> open in one terminal window and the command prompt in another. With each edit, save the file without exiting <code>vi</code>, using <code>:w</code>. Then in the other terminal run <code>kubectl create</code> or <code>kubectl apply</code> as appropriate until the command is successful. Then exit <code>vi</code>.</p>"},{"location":"information/yaml-faq/#gotchas","title":"Gotchas","text":"<p>Here we list any bugs in the GoLang YAML parser. By \"bugs\" we mean deviations from the YAML 1.2 Standard, whereby the parser does not behave as per the specification. These are traps for the unwary!</p> <ul> <li> <p>Key duplication is not reported as an error.</p> <p>As per section 3.2.1.3, a duplicate key should be reported as an error. Golang's parser (and thus <code>kubectl</code>) does not do this. Consider the following. Can you see the issue, and predict what will happen?</p> <p><code>yaml apiVersion: v1 kind: Pod metadata:   creationTimestamp: null   labels:     run: test   name: test spec:   volumes:   - name: data     emptyDir: {}   containers:   - image: nginx     name: test     resources:       requests:         cpu: 200m     volumeMounts:     - name: data       mountPath: /data     resources: {}   dnsPolicy: ClusterFirst   restartPolicy: Always</code></p> <ul> <li>What's wrong with the above?</li> </ul> <p> Reveal <p><code>resources:</code> is defined twice. This should be reported as an error, but is not!</p> <ul> <li>What will happen?</li> </ul> <p> Reveal <p>The last value found for <code>resources</code> is what will go into the pod, therefore you may think you set a CPU request, but in fact it will not be set, and if that's for an exam question, then it won't score!</p> <p>Try creating a pod from the above, and get it back with</p> <p><code>kubectl get pod test -o yaml</code></p> <p>and note the lack of resources!</p> <p>Could be any key, and the one which is most likely to nip you (especially if you're doing CKS) would be <code>securityContext</code> which can be defined at container and pod level. If you do a container <code>securityContext</code>, then a pod one later in the manifest and get the indentation wrong, it would be interpreted as a second entry at container level and trump the first one.</p>"},{"location":"information/yaml-faq/#yaml-practice-lab","title":"YAML practice lab","text":"<p>A lecture and practice lab may be found in this free course. Note that the lecture is taken from the Ansible course, however all the main concepts of YAML syntax are discussed.</p>"},{"location":"information/yaml-faq/#advanced-features","title":"Advanced features","text":"<p>Note that you are not required to understand this for the exams. This section is provided just to demonstrate the power of YAML if you master it!</p>"},{"location":"information/yaml-faq/#documents","title":"Documents","text":"<p>A single YAML file may contain multiple documents. Each resource in Kubernetes is described by a single document. Multiple documents in the same file are separated by the document separator which is</p> <pre><code>---\n</code></pre> <p>This means that you can declare for instance a deployment and a service to expose it in the same YAML file:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: nginx\n  name: nginx\n  namespace: default\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - image: nginx\n        name: nginx\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: nginx\n  name: nginx\n  namespace: default\nspec:\n  ports:\n  - port: 8080\n    protocol: TCP\n    targetPort: 8080\n  selector:\n    app: nginx\n  type: ClusterIP\n\n</code></pre>"},{"location":"information/yaml-faq/#aliases-and-anchors","title":"Aliases and Anchors","text":"<p>The GoLang YAML parser supports funky stuff like Aliases and Anchors, which help you to avoid repetition. Consider the case where you have a load of containers in a single pod, and they all require the same environment. You can do this:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx-with-anchors\nspec:\n  containers:\n  - name: c1\n    image: nginx:1.14.2\n    env: &amp;environment             # &lt;- anchor\n    - name: MY_NODE_NAME\n      valueFrom:\n        fieldRef:\n          fieldPath: spec.nodeName\n  - name: c2\n    image: nginx:1.14.2\n    env: *environment             # &lt;- alias (to above anchor)\n  - name: c3\n    image: nginx:1.14.2\n    env: *environment\n  - name: c4\n    image: nginx:1.14.2\n    env: *environment\n  - name: c5\n    image: nginx:1.14.2\n    env: *environment\n</code></pre> <p>Apply this pod, then get it back with</p> <pre><code>kubectl get pod nginx-with-anchors -o yaml\n</code></pre> <p>You will see that the environment for c1 is replicated to all the other containers. Neat huh?</p>"}]}